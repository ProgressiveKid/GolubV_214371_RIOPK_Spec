# GolubV_214371_RIOPK_Client
# ** Программное средство управления корпоративными рисками на основе внутреннего аудита **
Цель проекта — автоматизировать процессы выявления, оценки и мониторинга корпоративных рисков на основании данных внутреннего аудита. Система предоставляет удобный интерфейс для внутренних аудиторов, управляющих организацие и администраторов, а также реализует механизмы безопасности, авторизации пользователей и централизованного хранения информации о рисках.

**Сервер**: [ProgressiveKid/GolubV_214371_RIOPK_Server](https://github.com/ProgressiveKid/GolubV_214371_RIOPK_Server)
**Клиент**: [ProgressiveKid/GolubV_214371_RIOPK_Client](https://github.com/ProgressiveKid/GolubV_214371_RIOPK_Client)

---
## **Содержание**

1. [Архитектура](#архитектура)
2. [Функциональные возможности](#функциональные-возможности)
3. [Детали реализации](#детали-реализации)
4. [Тестирование](#тестирование)
5. [Установка и запуск](#установка-и-запуск)
6. [Лицензия](#лицензия)
7. [Контакты](#контакты)

---

## **Архитектура**

### C4-модель

#### Контекстный уровень
![image](https://github.com/user-attachments/assets/55fea538-845e-48b1-84d4-4b5c0cdda771)


#### Контейнерный уровень
![image](https://github.com/user-attachments/assets/7d51e7d4-9941-4837-945e-83d4b78fb5af)


#### Компонентный уровень
![image](https://github.com/user-attachments/assets/d8d49aaa-a3b6-4c04-a699-20109198a787)


### Схема данных
![image](https://github.com/user-attachments/assets/09b68576-134c-403f-8cb8-aebc16c41241)


```sql
-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;

DROP SCHEMA IF EXISTS corp_risk_management CASCADE;
CREATE SCHEMA corp_risk_management;
SET search_path TO corp_risk_management;


CREATE TABLE IF NOT EXISTS corp_risk_management.audit_reports
(
    report_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    title character varying(200) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    author_id integer NOT NULL,
    content text COLLATE pg_catalog."default",
    department_id integer NOT NULL,
    pdf_report bytea NOT NULL DEFAULT '\x'::bytea,
    CONSTRAINT audit_reports_pkey PRIMARY KEY (report_id)
);

CREATE TABLE IF NOT EXISTS corp_risk_management.departments
(
    department_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    name character varying(150) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    CONSTRAINT "PK_departments" PRIMARY KEY (department_id)
);

-- Вставка данных отделов
INSERT INTO corp_risk_management.departments (department_id, name, description) 
VALUES 
    (1, 'IT-отдел', 'Отдел информационных технологий, отвечающий за техническую инфраструктуру и программное обеспечение компании'),
    (2, 'Бухгалтерия', 'Финансовый отдел, занимающийся учетом, отчетностью и финансовыми операциями компании'),
    (3, 'Юридическая служба', 'Отдел, обеспечивающий правовое сопровождение деятельности компании и соблюдение законодательства');

CREATE TABLE IF NOT EXISTS corp_risk_management.risk_assessments
(
    assessment_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    risk_id integer NOT NULL,
    assessed_by_id integer NOT NULL,
    assessment_date timestamp with time zone NOT NULL DEFAULT CURRENT_DATE,
    impact_score smallint,
    probability_score smallint,
    notes text COLLATE pg_catalog."default",
    CONSTRAINT risk_assessments_pkey PRIMARY KEY (assessment_id)
);

CREATE TABLE IF NOT EXISTS corp_risk_management.risk_departments
(
    risk_id integer NOT NULL,
    department_id integer NOT NULL,
    CONSTRAINT risk_departments_pkey PRIMARY KEY (risk_id, department_id)
);

CREATE TABLE IF NOT EXISTS corp_risk_management.risks
(
    risk_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    title character varying(150) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    severity character varying(20) COLLATE pg_catalog."default" NOT NULL,
    likelihood character varying(20) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    created_by_id integer NOT NULL,
    "RiskType" integer NOT NULL DEFAULT 0,
    CONSTRAINT "PK_risks" PRIMARY KEY (risk_id)
);

CREATE TABLE IF NOT EXISTS corp_risk_management.users
(
    user_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    username character varying(100) COLLATE pg_catalog."default" NOT NULL,
    password_hash text COLLATE pg_catalog."default" NOT NULL,
    email character varying(150) COLLATE pg_catalog."default" NOT NULL,
    full_name character varying(200) COLLATE pg_catalog."default" NOT NULL,
    role character varying(50) COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT "PK_users" PRIMARY KEY (user_id)
);

INSERT INTO corp_risk_management.users (user_id, username, password_hash, email, full_name, role) 
VALUES 
    (2, '111@111', '111', '111@111', '111', 'Auditor'),
    (1, '222@222', '222', '222@222', '222', 'Manager'),
    (3, 'vsgolub@mail.ru', '111', 'vsgolub@mail.ru', 'Голуб Владислав Сергеевич', 'Administrator');

ALTER TABLE IF EXISTS corp_risk_management.audit_reports
    ADD CONSTRAINT audit_reports_author_id_fkey FOREIGN KEY (author_id)
    REFERENCES corp_risk_management.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_audit_author
    ON corp_risk_management.audit_reports(author_id);


ALTER TABLE IF EXISTS corp_risk_management.audit_reports
    ADD CONSTRAINT audit_reports_department_id_fkey FOREIGN KEY (department_id)
    REFERENCES corp_risk_management.departments (department_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE RESTRICT;
CREATE INDEX IF NOT EXISTS idx_audit_department
    ON corp_risk_management.audit_reports(department_id);


ALTER TABLE IF EXISTS corp_risk_management.risk_assessments
    ADD CONSTRAINT risk_assessments_assessed_by_id_fkey FOREIGN KEY (assessed_by_id)
    REFERENCES corp_risk_management.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;
CREATE INDEX IF NOT EXISTS idx_assessment_user
    ON corp_risk_management.risk_assessments(assessed_by_id);


ALTER TABLE IF EXISTS corp_risk_management.risk_assessments
    ADD CONSTRAINT risk_assessments_risk_id_fkey FOREIGN KEY (risk_id)
    REFERENCES corp_risk_management.risks (risk_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_assessment_risk
    ON corp_risk_management.risk_assessments(risk_id);


ALTER TABLE IF EXISTS corp_risk_management.risk_departments
    ADD CONSTRAINT risk_departments_department_id_fkey FOREIGN KEY (department_id)
    REFERENCES corp_risk_management.departments (department_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS "IX_risk_departments_department_id"
    ON corp_risk_management.risk_departments(department_id);


ALTER TABLE IF EXISTS corp_risk_management.risk_departments
    ADD CONSTRAINT risk_departments_risk_id_fkey FOREIGN KEY (risk_id)
    REFERENCES corp_risk_management.risks (risk_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS corp_risk_management.risks
    ADD CONSTRAINT risks_created_by_id_fkey FOREIGN KEY (created_by_id)
    REFERENCES corp_risk_management.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_risks_created_by
    ON corp_risk_management.risks(created_by_id);

END;
```
---

## **Функциональные возможности**

### Диаграмма вариантов использования
![image](https://github.com/user-attachments/assets/8e06d35c-c00d-46d2-85b1-8c6a57de4bc2)


### User-flow диаграмма

      
![image](https://github.com/user-attachments/assets/9c8dc499-5be4-4f9f-bb77-f1d327fcddae)
Рисунок 2.1 – user flow аудитора

 ![image](https://github.com/user-attachments/assets/8c976c8c-001a-42c9-b796-684ba95433dd)
Рисунок 2.2 – user flow руководителя

 ![image](https://github.com/user-attachments/assets/d22bd19a-29b6-4fee-a1cd-343f1f8062b1)
Рисунок 2.3 – user flow администратора



---

## **Детали реализации**

### UML-диаграммы

#### Диаграмма классов
![image](https://github.com/user-attachments/assets/330a5d5e-6bd4-4728-8586-d8642c4b45d9)

#### Диаграмма последовательностей
![image](https://github.com/user-attachments/assets/e24d20aa-3bbd-462a-98d9-7c857da33bf9)

### Спецификация API

Открыть в браузере:  
[http://127.0.0.1:8000/docs](http://127.0.0.1:7124/swagger)

SWAGGER YAML-файл: `swagger.json` генерируется автоматически.

### Безопасность

Использована куки-аунтефикация:
```
private async Task Authenticate(string userName, Role role)
{
    var claims = new List<Claim>
    {
        new Claim(ClaimsIdentity.DefaultNameClaimType, userName),
        new Claim("http://schemas.microsoft.com/ws/2008/06/identity/claims/role", role.ToString())
    };

    ClaimsIdentity id = new ClaimsIdentity(claims, "ApplicationCookie", ClaimsIdentity.DefaultNameClaimType, ClaimsIdentity.DefaultRoleClaimType);

    // Создание куки с AuthenticationProperties
    await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, new ClaimsPrincipal(id), new AuthenticationProperties
    {
        IsPersistent = true,
        ExpiresUtc = DateTimeOffset.UtcNow.AddYears(1)
    });
}
```

### Оценка качества кода

![image](https://github.com/user-attachments/assets/b760eb15-b0ff-472f-87d9-bc63a8622d50)


---

## **Тестирование**

### Unit-тесты

Покрытие:
- Проверка работы с рисками
- Проверка оценки рисков
- Проверка работы отчетов аудита
- Проверка получения данных о подразделениях
- Проверка работы с пользователями

![image](https://github.com/user-attachments/assets/e3d59399-df44-42ae-85a0-38e5708b34ec)


### Интеграционные тесты

```C#

using CorporateRiskManagementSystemBack.Infrastructure.Data;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.EntityFrameworkCore; // <-- Не забудьте добавить
using System.Net.Http.Json;
using System.Net;
using FluentAssertions;
using Xunit;
using CorporateRiskManagementSystemBack.Domain.Entites.DataTransferObjects.RequestModels;
using CorporateRiskManagementSystemBack.Domain.Entites;
using CorporateRiskManagementSystemBack;

namespace TestCRMS.Integrations
{
    public class ReportControllerIntegrationTests
    {
        private readonly HttpClient _client;
        private readonly WebApplicationFactory<Program> _factory;

        public ReportControllerIntegrationTests()
        {
            _factory = new WebApplicationFactory<Program>()
                .WithWebHostBuilder(builder =>
                {
                    builder.ConfigureServices(services =>
                    {
                        // Здесь нужно использовать InMemoryDatabase для тестов
                        var connection = "InMemoryDbForTesting"; // строка для имитации базы данных в памяти
                        services.AddDbContext<RiskDbContext>(options =>
                            options.UseInMemoryDatabase(connection));
                    });
                });

            _client = _factory.CreateClient();
        }

        [Fact]
        public async Task CreateReport_ReturnsBadRequest_WhenAnyRiskHasNoAssessment()
        {
            // Arrange: создаём риски и департамент с необходимыми данными
            var scopeFactory = _factory.Services.GetRequiredService<IServiceScopeFactory>();
            using var scope = scopeFactory.CreateScope();
            var dbContext = scope.ServiceProvider.GetRequiredService<RiskDbContext>();

            // Начинаем транзакцию
            var transaction = await dbContext.Database.BeginTransactionAsync();

            try
            {
                var userId = dbContext.Users.FirstOrDefault().UserId;
                // Создаём риски
                var department = new Department {  Name = "FinanceForTests" };
                dbContext.Departments.Add(department);

                var risk1 = new Risk
                {
                    Title = "Risk 1",
                    CreatedById = userId,
                    CreatedAt = DateTime.Now,
                    Description = "wake up on buggati",
                    Severity = "High",  // Установите значение для поля severity
                    Likelihood = "Low",
                };

                var risk2 = new Risk
                {
                    Title = "Risk 2",
                    CreatedById = userId,
                    Severity = "High",
                    CreatedAt = DateTime.Now,
                    Description = "wake up on buggati",
                    Likelihood = "Low",
                };

                dbContext.Risks.Add(risk1);
                dbContext.Risks.Add(risk2);
                dbContext.SaveChanges();

                var request = new CreateReportRequest
                {
                    Username = "admin",
                    DepartmentId = department.DepartmentId,
                    Content = "Контент"
                };

                var response = await _client.PostAsJsonAsync("/Report/CreateReport", request);

                // Assert: проверка на BadRequest с нужным сообщением
                response.StatusCode.Should().Be(HttpStatusCode.BadRequest);
                var content = await response.Content.ReadAsStringAsync();
                content.Should().Be("Необходимо выполнить оценку всех существующих рисков для отдела");
            }
            finally
            {
                // Откатываем все изменения, сделанные в рамках транзакции
                await transaction.RollbackAsync();
            }
        }
    }
}

```
---

## **Установка и запуск**

Для корректной работы программного средства необходимы следующие 
требования:
1. операционная система Windows 10, 11;
2. Microsoft .NET 8 SDK;
3. оперативная память – 2048 Мб;
4. свободное место на жестком диске – 500 Мб; 
51
Пошаговая инструкция по запуску:
1. Откройте Visual Studio и загрузите решение, выбрав файл 
CorparateRiskmanagment.sln.
2. Запустить через Docker-desktop сервер базы данных PostgreSQL, 
путём выполнения команды из директории проекта в папке testBD, команды 
docker-compose up
3. Восстановить структуру БД путём наката миграции на созданную 
пустую БД, для этого необходимо либо перейти в папку проекта 
«\CorporateRiskManagementSystemBack\CorporateRiskManagementSystemBack
» и выполнить следующую команду в консоли «dotnet ef database update»
либо выполнить SQL-скрипт "скрипт генерации из СУБД" - он лежит по пути
«\CorporateRiskManagementSystemBack\CorporateRiskManagementSystemBack»
4. В обозревателе решений установите оба проекта, как стартовые 
(ПКМ по проекту - «Настройка начальных проектов» - Выставить в 
radioButton пункт «Несколько запускаемых проектов» и в действии 
выставить запуск для CorparateRiskmanagment.Back и 
CorparateRiskmanagment.Frontend). Нажмите F5 или кнопку «Start». После 
запуска серверное API будет доступно по адресу http://localhost:7111/swagger. 
Клиентская часть проекта реализована как Razor Pages. после запуска 
клиентское приложение будет доступно по адресу http://localhost:7124.
5. Зарегистрироваться и авторизация в системе: Обычный пользователь 
может быть создан через форму регистрации на клиентской части (Razor 
Pages).

```

